import os


class Splyt:
    @staticmethod
    def split(secret, participants, threshold):
        """
        Split a secret ASCII string into N shares using Shamir Secret Sharing Scheme so that (at least) T shares
        are necessary to reconstruct the secret.
        :param secret: ASCII string to split
        :param participants: the number N of participants (number of shares returned)
        :param threshold: the number T of participants required to reconstruct the secret
        :return: shares: list of dictionaries [{"x":int, "y":[int]}]
        """
        coefficients = Splyt.pick_coefficients(threshold)
        shares = []
        for i in range(participants):
            x = i + 1
            share = {"x": x, "y": []}
            for s in secret:
                y = Splyt.compute_poly(x, ord(s), coefficients)
                share["y"].append(y)
            shares.append(share)

        return shares

    @staticmethod
    def join(shares):
        """
        Rejoin a list of secrets generated by split(), using Lagrange
        :param shares: a list of dictionaries returned by split()
        :return: the original string
        """
        secret = ""
        secret_len = len(shares[0]["y"])
        for i in range(secret_len):
            points = [{"x": share["x"], "y": share["y"][i]} for share in shares]
            secret += chr(Splyt.compute_lagrange_interpolating_polynomial(0, points))
        return secret

    @staticmethod
    def pick_coefficients(threshold):
        return [b for b in os.urandom(threshold - 1)]

    @staticmethod
    def compute_poly(x, secret, coefficients):
        y = secret
        for i, coefficient in enumerate(coefficients):
            y = (y + coefficient * int(x ** (i+1))) % 255
        return y

    @staticmethod
    def compute_lagrange_interpolating_polynomial(x, points):
        s = 0
        for i, point in enumerate(points):
            s = (s + point["y"] * Splyt.lagrange_basis_polynomial(x, points, i)) % 255
        return s

    @staticmethod
    def lagrange_basis_polynomial(x, points, i):
        numerator = 1
        denominator = 1
        for j, p in enumerate(points):
            if i == j:
                continue
            numerator *= (x - p["x"])
            denominator *= (points[i]["x"] - p["x"])
        return int(numerator/denominator)
